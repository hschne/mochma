#! /usr/bin/env bash

set -Eeuo pipefail

TAGS='TODO,FIXME'

INCLUDE_GLOB=
EXCLUDE_GLOB=

mochma() {
  parse_args "$@"

  local files; files=$(git ls-files)
  [[ -n $EXCLUDE_GLOB ]] && files=$(echo "$files" | grep -vE "$EXCLUDE_GLOB" )
  [[ -n $INCLUDE_GLOB ]] && files=$(echo "$files" | grep -E "$INCLUDE_GLOB" )
  files=$(echo "$files" | xargs git --no-pager grep -rn -E 'TODO:|FIXME:')

  local annotated_line
  while IFS=$'\n' read -r line; do
    annotated_line=$(get_blame "$line")
    print_blame "$annotated_line"

  done <<< "$files"
}

# Argument parsing, ripped from SO
# See https://stackoverflow.com/a/28466267/2553104
parse_args() {
  while getopts he:i: OPT; do
    if [ "$OPT" = "-" ]; then   
      OPT="${OPTARG%%=*}"      
      OPTARG="${OPTARG#$OPT}" 
      OPTARG="${OPTARG#=}"   
    fi
    case "$OPT" in
      h | help )     usage ;;
      e | exclude )  needs_arg; EXCLUDE_GLOB="$OPTARG" ;;
      i | include )  needs_arg; INCLUDE_GLOB="$OPTARG" ;;
      ??* )          die "Illegal option --$OPT" ;;  # bad long option
      \? )           exit 2 ;;  # bad short option (error reported via getopts)
    esac
  done
  shift $((OPTIND-1))
}

get_blame() {
  local line=$1
  local file line_number text comment matcher
  file=$(echo "$line" | cut -d':' -f1)
  line_number=$(echo "$line" | cut -d':' -f2)
  text=$(echo "$line" | cut -d':' -f3- | sed -e 's/^.*\(TODO\|FIXME\): \(.*$\)/\1\/\2/')
  matcher=${text%%/*}
  comment="${text#*/}"

  local blame
  blame=$(git blame --porcelain -L "$line_number","$line_number" "$file")
  local commit author_name author_mail timestamp
  commit=$(echo "$blame" | head -n 1 | cut -d' ' -f1)
  author_name=$(echo "$blame" | grep '^author ' | sed 's/author \(.*\)/\1/')
  author_mail=$(echo "$blame" | grep '^author-mail ' | sed 's/author-mail \(.*\)/\1/')
  timestamp=$(echo "$blame" | grep '^author-time ' | sed 's/author-time \(.*\)/\1/')

  printf "%s,%s,%s,%s,%s,%s,%s,\"%s\"\n" \
    "$file" "$line_number" "$commit" "$author_name" "$author_mail" "$timestamp" "$matcher" "$comment" 
}

print_blame() {
  local line=$1
  local file line_number matcher comment commit author_name author_mail timestamp

  file=$(echo "$line" | cut -d',' -f1)
  line_number=$(echo "$line" | cut -d',' -f2)
  commit=$(echo "$line" | cut -d',' -f3)
  author_name=$(echo "$line" | cut -d',' -f4)
  author_mail=$(echo "$line" | cut -d',' -f5)
  timestamp=$(echo "$line" | cut -d',' -f6)

  local pretty_time
  pretty_time=$(date -d "@$timestamp")

  matcher=$(echo "$line" | cut -d',' -f7)
  comment=$(echo "$line" | awk -vFPAT='([^,]*)|("[^"]+")' -vOFS=, '{print $8}')

  local temp sanitized_comment
  temp="${comment%\"}"
  sanitized_comment="${temp#\"}"

  local yellow="\e[33m"
  local default="\e[0m"
  printf "${yellow}%s${default}: %s\n" "$matcher" "$sanitized_comment" 
  printf "%2s=> %s:%s\n" "" "$file" "$line_number"
  printf "%2s=> On %s by %s %s in %s\n" "" "$pretty_time" "$author_name" "$author_mail" "$commit"
  echo
}

usage () {
  cat <<EOF

Usage: $0 [options]

A tickgit clone written in bash

Options: 
  -a, --author=NAME    Limit output to author
  -e, --exclude=GLOB   Exclude a number of files from being parsed
  -g, --group-by=COL   Group output by file, author or date. Default is date
  -h, --help           Exclude a number of files from being parsed
  -i, --include=GLOB   Limit to specified patterns
  -o, --order-by=COL   Sort output by file, author or date. Default is date
  -p, --porcelain      Produce machine readable output
  -t, --tags=TAGS      Set tags to scan for. Default is 'TODO,FIXME'
EOF

  exit 0
}

inside_work_tree() { git rev-parse --is-inside-work-tree >/dev/null; }

warn() { printf "%b[Warn]%b %s\n" '\e[0;33m' '\e[0m' "$@" >&2; }

info() { printf "%b[Info]%b %s\n" '\e[0;32m' '\e[0m' "$@" >&2; }

sourced() { [ "${0}" != "${BASH_SOURCE[0]}" ];  }

needs_arg() { if [ -z "$OPTARG" ]; then die "No arg for --$OPT option"; fi; }

die() { echo "$*" >&2; exit 1; } 

handle_error() { echo "An error occured, exit code $?"; }

trap 'handle_error $?' ERR

if ! sourced; then mochma "$@"; fi
